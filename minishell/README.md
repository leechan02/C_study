<h1 align="center">
    🐚 minishell
</h1>

<h3 align="center">
	<a href="#-about-the-project">프로젝트 소개</a>
	<span> · </span>
	<a href="#%EF%B8%8F-usage">사용법</a>
</h3>

## 📘 프로젝트 소개

`Minishell` 프로젝트는 Unix 기반의 작은 셸(Shell)을 구현하는 프로젝트입니다. 이를 통해 **시스템 호출**, **프로세스 관리**, **입출력 리다이렉션** 등 쉘의 기본 기능을 학습할 수 있습니다. 이 프로젝트의 목표는 간단한 셸을 구현하여 Unix 명령어를 처리하고, 파이프와 리다이렉션, 시그널 처리 등의 기능을 이해하는 것입니다.


## 💡 주요 목표

- **명령어 파싱 및 실행**: 사용자가 입력한 명령어를 파싱하고 실행하는 방법을 학습합니다.
- **프로세스 관리**: 여러 프로세스를 동시에 처리하고, 부모-자식 프로세스 간의 관계를 이해합니다.
- **리다이렉션과 파이프**: 입력과 출력을 파일이나 다른 명령어로 리다이렉션하고, 파이프를 통해 프로세스 간에 데이터를 전달합니다.
- **빌트인 명령어**: `echo`, `cd`, `pwd`, `export`, `unset`, `env`, `exit` 등의 기본 쉘 명령어를 직접 구현합니다.
- **시그널 처리**: 시그널(`Ctrl+C`, `Ctrl+D`, `Ctrl+Z` 등)을 처리하여 셸의 안정성을 높이고, 특정 입력에 대해 셸이 적절히 응답할 수 있도록 합니다.


## 📂 주요 개념

### 1. **셸(Shell)**
셸은 사용자와 운영 체제 사이의 인터페이스 역할을 하며, 사용자가 입력한 명령어를 해석하고 실행하는 프로그램입니다. 이 프로젝트에서는 Unix 셸의 기본 동작 방식을 모방하여 작은 셸을 구현합니다.

### 2. **프로세스 관리**
셸은 명령어를 실행할 때마다 새로운 프로세스를 생성합니다. **fork**, **execve**, **waitpid**와 같은 시스템 호출을 사용하여 자식 프로세스를 생성하고, 명령어를 실행한 후, 자식 프로세스가 종료되기를 기다립니다.

### 3. **리다이렉션과 파이프**
- **리다이렉션**: 명령어의 입력 또는 출력을 파일로 변경할 수 있습니다.
  - **`>`**: 출력을 파일로 리다이렉트.
  - **`<`**: 파일에서 입력을 읽어옵니다.
- **파이프(`|`)**: 파이프는 한 명령어의 출력을 다른 명령어의 입력으로 전달할 수 있게 해줍니다. 예를 들어, `ls | grep minishell`과 같은 명령어를 처리합니다.

### 4. **환경 변수 관리**
셸은 `env` 명령어를 통해 현재 환경 변수를 출력하고, `export`를 사용하여 새로운 환경 변수를 설정할 수 있습니다.

### 5. **시그널 처리 (Signal Handling)**

셸에서는 사용자가 입력하는 특정 키(`Ctrl+C`, `Ctrl+D`, `Ctrl+Z` 등)에 반응하여 적절하게 동작해야 합니다. 이를 위해 **시그널 처리**를 구현하여 다음과 같은 동작을 설정할 수 있습니다:

- **Ctrl+C (`SIGINT`)**: 현재 실행 중인 명령어를 종료하고, 프롬프트를 새로 띄웁니다.
- **Ctrl+D (`EOF`)**: `minishell`에서 **EOF**로 해석되며, 입력이 끝났음을 알리고 셸을 종료합니다.
- **Ctrl+Z (`SIGTSTP`)**: 기본적으로 프로세스를 중지하는 시그널이지만, 셸에서는 무시하도록 처리할 수 있습니다.

**시그널 처리 코드 예시**

```c
#include <signal.h>
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

// Ctrl+C 시그널 핸들러
void sigint_handler(int sig) {
    (void)sig;
    // 새 프롬프트 출력
    printf("\n");
    rl_on_new_line();    // 새로운 라인으로 이동
    rl_replace_line("", 0);  // 입력을 빈 줄로 교체
    rl_redisplay();      // 새로운 프롬프트 표시
}

// 시그널 설정 함수
void set_signal_handlers(void) {
    signal(SIGINT, sigint_handler);   // Ctrl+C
    signal(SIGQUIT, SIG_IGN);         // Ctrl+\
}
```

**주요 시그널 처리 동작**

- **SIGINT (`Ctrl+C`)**: 현재 실행 중인 프로세스를 중단시키고, 새로운 프롬프트를 출력합니다.
- **SIGQUIT (`Ctrl+\`)**: 셸에서 `Ctrl+\` 시그널을 무시하게 설정합니다.
- **SIGTSTP (`Ctrl+Z`)**: `SIGTSTP`는 셸에서 기본적으로 무시될 수 있지만, 필요에 따라 처리할 수 있습니다.

## 📊 주요 기능

### 1. **명령어 파싱**

쉘은 사용자가 입력한 명령어를 파싱하여 실행할 수 있는 구조로 변환합니다. 이 과정에서 명령어와 옵션, 인자, 리다이렉션 기호 등을 분리합니다.

```c
void parse_command(char *input) {
    // 명령어와 인자를 파싱하고, 리다이렉션이나 파이프를 처리합니다.
}
```

### 2. **프로세스 생성 및 실행**

`fork` 시스템 호출을 사용하여 자식 프로세스를 생성하고, `execve`로 명령어를 실행합니다. 부모 프로세스는 `waitpid`로 자식 프로세스의 종료를 기다립니다.

```c
pid_t pid = fork();
if (pid == 0) {
    execve(command, args, envp);
} else {
    waitpid(pid, &status, 0);
}
```

### 3. **입출력 리다이렉션 처리**

리다이렉션 기호(`>`, `<`)를 사용하여 명령어의 입력과 출력을 파일로 변경할 수 있습니다. `dup2` 함수로 파일 디스크립터를 변경하여 리다이렉션을 구현합니다.

```c
int fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, STDOUT_FILENO);
```

### 4. **파이프 처리**

파이프(`|`)를 사용하여 두 개 이상의 명령어를 연결할 수 있습니다. `pipe` 시스템 호출을 사용하여 두 프로세스 간의 데이터를 전달합니다.

```c
int pipe_fd[2];
pipe(pipe_fd);
```

### 4. **시그널 처리 설정**

`minishell`이 실행될 때 시그널 핸들러를 설정합니다. 이를 통해 사용자 입력에 따른 시그널을 적절히 처리할 수 있습니다.

```c
int main(void) {
    // 시그널 핸들러 설정
    set_signal_handlers();
    
    while (1) {
        // 사용자 입력 대기 및 명령어 실행
        char *input = readline("minishell$ ");
        if (!input)
            break;
        // 명령어 처리 함수 호출
        execute_command(input);
        free(input);
    }
    return 0;
}
```

## 🧠 프로그램 동작

### 1. **프로그램 실행 방법**

다음 명령어를 사용하여 `minishell`을 실행할 수 있습니다:

```bash
./minishell
```

`minishell`이 실행되면 쉘 프롬프트가 나타나고, 사용자 입력을 기다립니다. 일반적인 셸과 동일한 방식으로 명령어를 입력하면 됩니다.

**예시**:
```bash
minishell$ echo "Hello, World!"
Hello, World!
minishell$ ls | grep minishell
minishell.c
```

### 2. **지원하는 빌트인 명령어**

`minishell`은 다음과 같은 빌트인 명령어를 지원합니다:

- `echo`: 문자열을 출력합니다.
- `cd`: 디렉토리를 변경합니다.
- `pwd`: 현재 디렉토리 경로를 출력합니다.
- `export`: 환경 변수를 설정합니다.
- `unset`: 환경 변수를 삭제합니다.
- `env`: 현재 환경 변수를 출력합니다.
- `exit`: 쉘을 종료합니다.


## 🛠️ 주요 함수 및 기능

### 1. **프로세스 관련 함수**

- **fork()**: 새로운 프로세스를 생성하여 자식 프로세스로 명령어를 실행합니다.
- **execve()**: 명령어를 실행합니다.
- **waitpid()**: 자식 프로세스가 종료될 때까지 대기합니다.

### 2. **리다이렉션 관련 함수**

- **open()**: 파일을 열어 출력 또는 입력에 사용할 수 있습니다.
- **dup2()**: 파일 디스크립터를 변경하여 리다이렉션을 구현합니다.
- **close()**: 사용이 끝난 파일 디스크립터를 닫습니다.

### 3. **파이프 관련 함수**

- **pipe()**: 파이프를 생성하여 프로세스 간 데이터를 전달합니다.
- **dup2()**: 파이프의 출력과 입력을 연결합니다.
- **close()**: 파이프의 끝을 닫아 더 이상 데이터를 전송하지 않도록 합니다.


## 📋 중요한 개념

### 1. **프로세스 관리**

셸은 사용자 명령어를 처리하기 위해 새로운 프로세스를 생성하고, 이 프로세스가 작업을 완료할 때까지 대기합니다. 부모-자식 프로세스의 관계와 시스템 호출의 흐름을 이해하는 것이 중요합니다.

### 2. **리다이렉션과 파이프**

리다이렉션은 명령어의 입출력을 변경할 수 있는 방법이고, 파이프는 두 명령어를 연결하여 데이터를 전달하는 방법입니다. 이를 통해 여러 명령어를 결합하고, 복잡한 작업을 간단하게 처리할 수 있습니다.

### 3. **시그널 처리**

시그널은 운영 체제가 프로세스에 보내는 이벤트 알림입니다. 사용자의 입력에 따른 특정 시그널(`Ctrl+C`, `Ctrl+D`, `Ctrl+Z` 등)을 처리하고, 셸이 안정적으로 작동할 수 있도록 해야 합니다.


## 📚 참고 자료

- [Unix 시스템 호출](https://en.wikipedia.org/wiki/Unix_system_calls)
- [POSIX 프로세스 관리](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html)
- [입출력 리다이렉션](https://www.geeksforgeeks.org/input-output-redirection-c/)
- [파이프 사용법](https://www.geeksforgeeks.org/pipe-system-call/)
