## 1. 파일 디스크립터 (fd : File Descriptor)

---

### 1) 파일 디스크립터란?

- 유닉스 시스템에서는 프로세스가 파일들에 접근 할 때 `파일 디스크립터`라는 개념을 이용하도록 되어있다.
- 응용 프로세스가 파일을 열거나 생성 하게 되면 정수로 된 `파일 디스크립터`를 얻게 되는데 이는 모든 파일에 대한 동작을 수행할 수 있도록 `FD Table`을 참조하는데 사용되는 `index`이다.
- 기본적으로 파일 디스크립터는 정수형으로 차례로 넘버링 되고 `0,1,2`는 이미 할당되어 있어서 3부터 파일 디스크립터를 부여한다. `0` : 표준입력 `(Standard Input)` `1` : 표준출력 `(Standard Output)` `2` : 표준에러 `(Standard Error)`

### 2) 파일 디스크립터 제한

- 운영체제에서 사용할 수 있는 `파일 디스크립터` 는 제한되어있다. 이 값은 사용하는 운영체제 혹은 머신에 따라서도 달라질 수 있다. 또한 얼마만큼의 `파일 디스크립터`를 가용할지에 대해서도 권한이 있는 사용자에 한하여 그 값을 번경하는 것이 가능하다.

<aside>
💡 `getconf` (OPEN_MAX) 명령어 : 시스템 구성 변수값을 표준 출력에 기록합니다.
ulimit `-n` : `open files` 값 확인과 변경 (`49152`가 클러스터 맥 최대값.) 환경마다 다름

</aside>

- 시스템 상에서 정의된 최대치를 알아내기 위해선 다음과 같은 명령어를 이용한다. 이는 시스템 상에서 정의된 값이 아니라 시스템 및 운영체제에 따라 언어에서 정의된 값이므로 정확한 수치를 나타내지 않는다는 것을 유의해야 한다.

<aside>
🧑🏻‍💻 `ulimit` : 프로세스가 사용하는 자원에 대한 제어(user limit)를 관리할 수 있게 도와줍니다.
ulimit에서 설정하게 되는 값에 따라 프로그램에서 소켓 커넥션 수, 혹은 생성 가능한 쓰레드 수가 제한된다.
하드 설정 확인 : `ulimit -a -H` : root 사용자만 값을 증가 시킬 수 있음.
소프트 설정 확인 : `ulimit -a -S`
소프트 값은 0과 하드 limit 사이의 값을 가질 수 있다. `(0 <= soft limit <= hard limit)`

</aside>

- `OPEN_MAX`의 값을 알아야 하는 이유는 배열로 문제를 풀어나갈 때 `파일 디스크립터`의 값이 다른 것을 가르키면 파일이 터졌다는 뜻을 알기 위해서다. `연결리스트`를 활용해서 구현을 하면 `OPEN_MAX`값을 알 필요가 없다.
- `<limists.h>`에 선언된 `OPEN_MAX`값이 있다. = `10240`
- `BUFFER`는 임시저장 공간.

### 3) 파일 디스크립터 확인

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
	int fd;

	fd = open("test.txt", O_RDONLY); //RDONLY = 읽기 전용 WDONLY = 쓰기 전용?
	if (fd == -1)
		return (1);
	printf("fd : %d\n", fd);
	close(fd);
	return (0);
}
```

- 출력된 `3`은 `표준 입력`, `표준 출력`, `표준 오류`를 지칭하는 `index`의 바로 다음 값이다.
- open 인자값
`O_RDONLY`
읽기 전용으로 파일을 연다. 쓸 수 없다.
`O_WRONLY`
쓰기 전용으로 파일을 연다.
`O_RDWR`
읽기와 쓰기 모두 가능하도록 파일을 연다.
`O_CREAT`
파일이 존재하지 않을 경우 파일을 생성한다.
`O_EXCL`
`O_CREAT`를 써서 파일을 오픈 할 경우, 이미 파일이 존재한다면 error를 리턴하게 한다. 파일을 덮어쓰거나 하는 실수를 방지하기 위한 용도로 사용할 수 있다.

## 2. File Control을 위한 함수들

---

### 1) open, close

```c
<fcntl.h>

int open(const char *filename, int flags, [mode_t mode]);
```

- `open` 함수는 `filename`에 해당하는 파일을 열고, 해당 파일을 참조할 수 있는 `파일 디스크립터`를 반환한다. 편재 이용 가능한 `파일 디스크립터`들 중 가장 작은 값을 반환 받아 `index`로 이용하게 된다.
- 성공하면 `파일 디스크립터`를, 실패하면 `-1`을 반환한다.

```c
<unistd.h>

int close(int fd);
```

- `close` 함수는 `open` 함수를 통해 반환 받은 `파일 디스크립터`를 닫는 역할을 수행한다. 정확히는 `File Table`의 `entry` 주소를 지워 참조할 수 없게 만들어, `entry`의 `f_count`를 하나 감소시키도록 만든다.
- 정상적으로 종료되면 `0`을, 실패하면 `-1`을 반환한다.

### 2) read

```c
<unistd.h>

ssize_t read(int fd, void *buf, size_t n);
```

- 파일을 열고 난 후 데이터를 읽어올 때에는 `read` 함수를 사용한다. `read` 함수는 파일에서 `n` 만큼 읽어와서 `buf`에 그 값을 할당하게 된다.
- 함수를 정상적으로 수행한 경우에는 `읽은 바이트 수`를, 그렇지 않다면 `-1`을 반환한다.
- 파일을 끝까지 읽었으면, 다음 번에는 더 이상 읽을 바이트가 없기 때문에 `0`을 반환한다.

<aside>
💡 **size_t와 ssize_t?**

`size_t`는 객체의 크기를 나타내기 위한 `type`으로 보통의 `32 bit` 머신에서는 `32 bit` 크기를 가지며 `unsigned int`로 되어있다.

`ssize_t`는 부호가 있는 형태로 객체의 크기를 나타내기 위한 `type`으로 보통의 `32 bit` 머신에서는 `32 bit` 크기를 가지며 `int`로 되어있다.

</aside>

### ****3) write 함수****

```c
<unistd.h>

ssize_t write(int fd, const void *buf, size_t n);
```

- 파일을 열고 난 후 파일에 값을 기록할 때는 `write` 함수를 사용한다. 함수 정상적으로 수행한 경우에는 `기록한 바이트 수`를, 그렇지 않다면 `-1`을 반환한다.

## 3. 프로그램과 프로세스에 대하여

---

### 1) Program 이란?

- 프로그램이란 컴퓨터에서 실행되는 명령어 모음이 들어있는 덩어리라고 볼 수 있다. 이 때의 덩어리는 `code`와 `data`로 나뉜다.
- 프로그램을 실행하면 프로그램 안에 있는 명령어를 한 줄 씩 수행하면서 프로그램이 뭔가 실행하는 등의 상태를 갖게 되는데, 이렇게 프로그램이 `상태(state)`를 갖고 있는 것을 프로세스라고 한다.

### 2) Process 란?

- 프로세스는 운영체제에 의해서 관리 되며, 프로세스 별로 사용 가능한 메모리 영역이 존재한다.
- 프로그램이 프로세스로써 돌아가게 되면 프로그램의 `Code`와 `Data`는 프로세스 메모리로 불러들여 진다.
- 이 때 프로세스는 `Code Segment`, `Data Segment`, `Heap`, `Stack`의 구조로 메모리 레이아웃을 가진다.
- 프로그램은 `HDD, SSD`와 같은 곳에 존재하고, 프로세스는 `RAM`에 존재한다.

<aside>
🧑🏻‍💻 일반적인 `Stack`의 크기는 수십KB ~ 수십MB 정도이다. 이 크기는 시스템에 따라 상이하며, 지역 변수를 이용할 때 `Stack`을 이용하기 때문에 큰 배열을 지역 변수로 선언하면 `Stack` 용량 부족 문제를 겪을 수 있다. 지역 변수 이외에도 `Stack`에는 함수의 호출 기록 및 매개 변수 등에 대해 보유하게 되며, 이들은 모두 중괄호의 `Block` 단위로 관리되어 중괄호를 마치면 `Stack`에서 사용되었던 모든 것들이 `Stack Frame`을 벗겨내면서 해제된다.

따라서 이를 해결하기 위해선 시스템 설정으로 `Stack`의 크기를 강제로 늘려주거나, 메모리 이용을 `Stack`을 피하면 된다. 이는 `정적 변수` 혹은 `전역 변수` 로 선언하여 `Data Segment`에 위치시키거나 `Heap`으로부터 메모리를 할당 받으면 된다는 것이다.

</aside>

## 4. static 변수

---

### 1) static 변수란?

- `static` 변수는 `Global`, `Local` 어느 것으로 이용이 가능하다.
- 전역이든 지역이든 `static` 변수는 `Data Segment`에 위치한다.
- 정적 변수는 함수를 벗어나더라도 변수가 사라지지 않고 계속 유지된다.

### 2) 외부 정적 변수

- 전역으로 선언된 `static`변수는 외부 정적 변수라고도 불리며, 별도의 초기화 구문이 없다면 `0`으로 초기화된다. 이 때는 `Data Segment`의 `BSS` 영역에 위치하여 `0`으로 초기화된다.
- 초기화 구문 존재 시에는 `Data Segment`의 `Data` 영역에 위치한다. 초기화 구문에는 함수 호출 구문을 이용하지 않도록 주의해야 한다. 함수 호출은 런 타임에 이뤄지므로 런 타임 이전에 그 값이 결정되는 `static` 변수에는 이용할 수 없다.

### 3) 내부 정적 변수

- 특정 함수나 클래스 내부에 선언된 `지역 변수`는 `내부 정적 변수`라고도 불리며, `외부 정적 변수`와 마찬가지로 별도의 초기화 구문이 없으면 `0`으로 초기화 된다.

### 4) ****static 변수는 매개 변수로 사용할 수 없다.****

- 매개 변수에 static을 붙이더라도 매개 변수는 static으로써의 역할을 수행할 수 없다. 즉, 값이 유지 되지 않는다.

## 5. 포인터

---

### 1) dangling pointer

- 그림
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9dd41b3-64ae-452c-879b-7a994672ff42/Untitled.png)
    
- 포인터가 여전히 해제된 메모리 영역을 가리키고 있다면, 이러한 포인터를 댕글링 포인터(Dangling Pointer)라고 한다.

### 2) 이중 포인터

- 읽어들인 라인(char *)의 주소를 저장하기 위함.

## 6. 메모리

---

### 1) 메모리 릭
