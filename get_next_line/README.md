<h1 align="center">
	⏳ get_next_line
</h1>

<h3 align="center">
	<a href="#-about-the-project">프로젝트 소개</a>
	<span> · </span>
	<a href="#%EF%B8%8F-usage">사용법</a>
</h3>

## 📘 프로젝트 소개

`get_next_line` 프로젝트는 C 언어에서 파일 또는 표준 입력을 읽어올 때, 한 번에 한 줄씩 읽어오는 함수를 구현하는 것을 목표로 합니다. 이 프로젝트는 파일 디스크립터(fd)를 사용하여 여러 파일을 동시에 처리할 수 있으며, 메모리 관리와 버퍼 크기를 조절하여 효율적으로 데이터를 처리합니다.

---

## 💻 필수 구현 사항

- **함수 프로토타입:**

```c
char *get_next_line(int fd);
```

- **기능 설명:**
  - `get_next_line` 함수는 주어진 파일 디스크립터 `fd`를 이용해 파일을 한 줄씩 읽어옵니다. 파일 끝에 도달하면 `NULL`을 반환하며, 메모리 누수가 발생하지 않도록 관리합니다.
  - 여러 파일 디스크립터를 동시에 열어두고 각각의 파일에서 한 줄씩 순차적으로 읽어오는 기능을 지원합니다.
  
- **파일 디스크립터**란?
  - 운영체제에서 파일, 소켓 등을 식별하는 정수형 값을 의미하며, 이를 이용해 파일 입출력을 처리합니다. 
  - 기본적으로 `0`, `1`, `2`는 각각 표준 입력, 표준 출력, 표준 에러를 의미하며, 새로 열리는 파일은 3 이상의 값으로 할당됩니다.

---

## ⚙️ 사용법

- `BUFFER_SIZE`는 읽기 작업 시 사용할 버퍼 크기를 정의합니다. 적절한 값으로 설정하여 성능을 최적화할 수 있습니다.

```c
#define BUFFER_SIZE 42
```

- 파일을 열어 파일 디스크립터를 얻은 후 `get_next_line` 함수를 사용해 파일의 각 줄을 읽어올 수 있습니다.

```c
#include "get_next_line.h"
#include <fcntl.h>
#include <stdio.h>

int main(void)
{
    int fd = open("test.txt", O_RDONLY);
    char *line;

    while ((line = get_next_line(fd)) != NULL)
    {
        printf("%s", line);
        free(line); // 메모리 해제
    }
    close(fd);
    return (0);
}
```

---

## 📂 주요 개념

### 1. **동적 메모리 할당**
   - `get_next_line` 함수는 읽은 데이터를 동적으로 할당하여 반환하며, 이를 사용한 후 반드시 `free()`를 통해 메모리를 해제해야 메모리 누수를 방지할 수 있습니다.

### 2. **파일 디스크립터 관리**
   - 여러 파일을 동시에 처리할 때, 각 파일 디스크립터마다 별도의 버퍼와 읽기 상태를 관리하여 각 파일의 진행 상태를 유지할 수 있습니다.

### 3. **BUFFER_SIZE**
   - 한 번에 읽어올 데이터의 크기를 조절하는 상수로, 적절한 크기를 설정하면 성능과 메모리 사용의 균형을 맞출 수 있습니다. 너무 작으면 파일 읽기 성능이 떨어지고, 너무 크면 메모리 낭비가 발생할 수 있습니다.

---

## 🧠 메모리 관리

### 1. **정적 변수**
   - `get_next_line` 함수 내부에서 파일 읽기 상태를 유지하기 위해 정적 변수를 사용할 수 있습니다. 정적 변수는 함수 호출이 종료되어도 값을 유지하며, 여러 호출에 걸쳐 상태를 관리할 수 있게 해줍니다.
  
### 2. **메모리 릭 방지**
   - 동적으로 할당된 메모리는 사용 후 반드시 `free()` 해야 하며, 특히 파일 읽기가 완료되거나 프로그램이 종료되기 전에 모든 메모리를 해제해야 합니다.

---

## 🧰 프로젝트 빌드 및 실행

### Makefile 사용법

- `make`: 프로젝트를 컴파일하고 라이브러리(`get_next_line.a`)를 생성합니다.
- `make clean`: 컴파일 후 생성된 오브젝트 파일을 삭제합니다.
- `make fclean`: 오브젝트 파일 및 라이브러리를 삭제합니다.
- `make re`: 클린 후 다시 빌드합니다.

### 테스트 방법

1. 프로젝트를 빌드한 후, 테스트 파일을 준비하여 파일을 열고 `get_next_line` 함수로 파일의 각 줄을 읽어올 수 있습니다.
2. 여러 파일을 동시에 테스트하여 각 파일 디스크립터가 독립적으로 관리되는지 확인할 수 있습니다.

---

## 참고 문서

- [man 2 open](https://linux.die.net/man/2/open)
- [man 2 read](https://linux.die.net/man/2/read)
- [man 2 close](https://linux.die.net/man/2/close)
